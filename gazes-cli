#!/bin/bash

# VLC password and API endpoint
vlc_password="your_vlc_password" # Set your VLC password here
api="https://api.gazes.fr/anime"

# Arrays to store process IDs
pids=()
spinner_pid=""

# Cleanup function to terminate all child processes and clean up resources
cleanup() {
  echo "Cleaning up..."

  # Kill all stored process IDs
  if [ -n "${pids[*]}" ]; then
    kill "${pids[@]}" >/dev/null 2>&1
  fi

  stop_spinner

  echo "All processes should be terminated now."
  echo "Exiting gracefully."
  exit 1
}

# Trap SIGINT and SIGTERM to execute the cleanup function
trap 'cleanup' SIGINT SIGTERM

# Start a spinner using gum to indicate downloading progress
start_spinner() {
  local message="Downloading $total_episodes episodes..."
  gum spin --spinner dot --title "$message" -- sleep infinity &
  spinner_pid=$!
}

# Stop the spinner
stop_spinner() {
  if [ -n "$spinner_pid" ]; then
    kill "$spinner_pid" >/dev/null 2>&1
    wait "$spinner_pid" 2>/dev/null
  fi
}

# Fetch and select anime from the API using fzf for interactive selection
get_anime() {
  local result
  result=$(curl -s "${api}/animes" | jq -r .data)
  if [ $? -ne 0 ]; then
    echo "Failed to fetch anime data."
    exit 1
  fi

  local title
  title=$(echo "$result" | jq -r '.[].title' | fzf)
  if [ -z "$title" ]; then
    echo "No anime selected. Exiting."
    exit 1
  fi

  local anime
  anime=$(echo "$result" | jq -r ".[] | select(.title == \"$title\")")
  local anime_id
  anime_id=$(echo "$anime" | jq -r ".id")
  anime=$(curl -s "${api}/animes/${anime_id}")

  echo "$anime"
}

# Sanitize filenames to ensure compatibility with file systems
sanitize_filename() {
  echo "$1" | tr '[:upper:]' '[:lower:]' | tr -cd '[:alnum:]_-' | tr ' ' '_'
}

# Download an episode using ffmpeg and save to the specified folder
download_episode() {
  local anime_title="$1"
  local season_num="$2"
  local episode_num="$3"
  local episode_url="$4"
  local folder="$5"

  local output_file
  output_file="$folder/$anime_title/$(printf "%s S%02dE%02d.mp4" "$anime_title" "$season_num" "$episode_num")"
  mkdir -p "$folder/$anime_title"

  if ffmpeg -loglevel error -i "$episode_url" -c copy "$output_file"; then
    echo "Downloaded episode $episode_num successfully."
    update_playlist "$folder" "$anime_title"
  else
    echo "Failed to download episode $episode_num."
  fi
}

# Update the playlist file with the new episode
update_playlist() {
  local folder="$1"
  local anime_title="$2"
  local playlist_path="$folder/$anime_title/playlist.m3u8"

  echo "#EXTM3U" >"$playlist_path"
  for ep_file in $(ls "$folder/$anime_title"/*.mp4 | sort -V); do
    realpath "$ep_file" >>"$playlist_path"
  done
}

# Create a playlist for all episodes in the specified folder
create_playlist() {
  local folder="$1"
  local playlist_path="$folder/playlist.m3u8"

  if [ ! -d "$folder" ]; then
    echo "Folder '$folder' does not exist."
    exit 1
  fi

  echo "#EXTM3U" >"$playlist_path"
  for ep_file in $(ls "$folder"/*.mp4 | sort -V); do
    realpath "$ep_file" >>"$playlist_path"
  done

  echo "Playlist created at $playlist_path"
}

# Main download function to fetch and download selected anime episodes
download() {
  local folder="${2:-.}" # Default to current directory if folder not specified
  local anime
  anime=$(get_anime)

  if [ -z "$anime" ]; then
    echo "Please select an anime"
    exit 1
  fi

  local anime_id
  anime_id=$(echo "$anime" | jq -r ".data.id")
  local anime_title
  anime_title=$(echo "$anime" | jq -r ".data.title" | sed 's/"/\\"/g')
  local selected_episodes
  selected_episodes=$(echo "$anime" | jq -r ".data.episodes[].title" | gum choose --no-limit --header "Choose episodes to download")

  if [ -z "$selected_episodes" ]; then
    echo "You must select at least one episode"
    exit 1
  fi

  local lang
  lang=$(gum choose --height 4 --header "Language" {vf,vostfr})

  if [ -z "$lang" ]; then
    echo "Language selection required"
    exit 1
  fi

  IFS=$'\n' read -r -d '' -a episodes <<<"$selected_episodes"

  total_episodes=${#episodes[@]}

  start_spinner

  for episode in "${episodes[@]}"; do
    (
      local episode_num
      episode_num=$(echo "$anime" | jq -r ".data.episodes[] | select(.title == \"$episode\") | .num")
      local season_num
      season_num=$(echo "$anime" | jq -r ".data.episodes[] | select(.title == \"$episode\") | .season // 1") # Default season to 1 if not available
      local episode_full
      episode_full=$(curl -s "${api}/animes/${anime_id}/${episode_num}")
      local episode_url
      episode_url=$(echo "$episode_full" | jq -r ".data.${lang}.videoUri // .data.vostfr.videoUri")

      if curl --output /dev/null --silent --head --fail "$episode_url"; then
        download_episode "$anime_title" "$season_num" "$episode_num" "$episode_url" "$folder"
      else
        echo "Episode URL $episode_url not accessible."
      fi
    ) &
    pids+=($!)
  done

  wait "${pids[@]}"
  stop_spinner

  echo "Download completed."
}

# Print usage instructions
print_usage() {
  echo "Usage: $0 download|playlist [folder]"
  exit 1
}

# Main case statement to handle different commands: download and playlist
case "$1" in
download)
  download "$@"
  ;;
playlist)
  if [ -z "$2" ]; then
    echo "Please specify the folder."
    exit 1
  fi
  create_playlist "$2"
  ;;
*)
  print_usage
  ;;
esac

